'use server';

import { createClient } from '@/lib/supabase-server';
import { writeFileSync, readFileSync, unlinkSync, mkdirSync, existsSync, readdirSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function convertPdfToHtml(fileUrl: string, documentId: string, userId: string) {
  try {
    console.log('=== SERVER ACTION STARTED ===');
    console.log('Server action - Converting PDF for user:', userId);
    console.log('Server action - File URL:', fileUrl);
    console.log('Server action - Document ID:', documentId);
    
    // Create server-side Supabase client with proper auth context
    const supabase = createClient();

    console.log('About to download PDF from storage...');
    
    // Download the PDF from Supabase Storage
    const { data: pdfBuffer, error: downloadError } = await supabase.storage
      .from('documents')
      .download(fileUrl);
    
    console.log('Download result:', { 
      hasData: !!pdfBuffer, 
      error: downloadError,
      fileUrl 
    });
    
    if (downloadError || !pdfBuffer) {
      console.error('Server action - Download error:', downloadError);
      throw new Error('Failed to download PDF from storage');
    }
    
    console.log('PDF downloaded successfully, size:', pdfBuffer.size);

    // Create temporary directory
    const tempDir = join(tmpdir(), `pdf-conversion-${Date.now()}`);
    if (!existsSync(tempDir)) {
      mkdirSync(tempDir, { recursive: true });
    }

    // Create input and output directories for Docker volume mounting
    const inputDir = join(tempDir, 'input');
    const outputDir = join(tempDir, 'output');
    mkdirSync(inputDir, { recursive: true });
    mkdirSync(outputDir, { recursive: true });

    // Save PDF to input directory
    const pdfPath = join(inputDir, 'input.pdf');
    const arrayBuffer = await pdfBuffer.arrayBuffer();
    writeFileSync(pdfPath, Buffer.from(arrayBuffer));
    
    console.log('PDF saved to:', pdfPath);
    console.log('About to test Docker availability...');
    
    // Test if Docker is available
    try {
      const { stdout: dockerVersion } = await execAsync('docker --version');
      console.log('Docker version:', dockerVersion.trim());
    } catch (dockerError: any) {
      console.error('Docker not available:', dockerError?.message);
      throw new Error('Docker is not available on the system');
    }

    // Convert PDF to HTML using pdf2htmlEX with custom CSS for better layout
    const customDataDir = join(process.cwd(), 'custom-data');
    
    // Use default pdf2htmlEX conversion, then post-process with custom CSS
    console.log('Using default pdf2htmlEX conversion with post-processing');
    
    const dockerCommand = `docker run --rm -v "${inputDir}:/pdfs" -v "${outputDir}:/output" pdf2htmlex/pdf2htmlex:0.18.8.rc2-master-20200820-alpine-3.12.0-x86_64 --dest-dir /output /pdfs/input.pdf output.html`;
    
    console.log('Executing Docker command:', dockerCommand);
    
    try {
      const { stdout, stderr } = await execAsync(dockerCommand);
      
      if (stderr) {
        console.log('pdf2htmlEX stderr:', stderr);
      }
      if (stdout) {
        console.log('pdf2htmlEX stdout:', stdout);
      }
    } catch (execError: any) {
      console.error('Docker execution error:', execError);
      console.error('Error details:', {
        message: execError?.message || 'Unknown error',
        code: execError?.code || 'Unknown',
        signal: execError?.signal || 'Unknown',
        stdout: execError?.stdout || 'None',
        stderr: execError?.stderr || 'None'
      });
      throw new Error(`Docker execution failed: ${execError?.message || 'Unknown error'}`);
    }

    // Read all generated files
    const files = readdirSync(outputDir);
    console.log('Generated files:', files);

    let htmlContent = '';
    
    // Check for the main HTML file
    const htmlFile = join(outputDir, 'output.html');
    if (existsSync(htmlFile)) {
      const fileContent = readFileSync(htmlFile, 'utf-8');
      console.log('HTML content preview:', fileContent.substring(0, 200));
      htmlContent = fileContent;
    } else {
      // Check for alternative naming patterns
      const htmlFiles = files.filter(file => file.endsWith('.html'));
      if (htmlFiles.length > 0) {
        const firstHtmlFile = join(outputDir, htmlFiles[0]);
        htmlContent = readFileSync(firstHtmlFile, 'utf-8');
        console.log('Using alternative HTML file:', htmlFiles[0]);
      } else {
        throw new Error('HTML file was not generated by pdf2htmlEX');
      }
    }
    
    // Inject custom CSS for better layout
    const customCss = `
    <style>
    /* Custom layout CSS to fix pdf2htmlEX output */
    
    /* Force natural flow for all elements */
    * {
      position: static !important;
      top: auto !important;
      left: auto !important;
      right: auto !important;
      bottom: auto !important;
      transform: none !important;
    }
    
    /* Make text visible and flow naturally */
    span {
      visibility: visible !important;
      opacity: 1 !important;
      color: #333 !important;
      display: inline !important;
      white-space: normal !important;
      word-wrap: break-word !important;
      line-height: 1.6 !important;
    }
    
    /* Make images flow with text */
    img {
      max-width: 100% !important;
      height: auto !important;
      display: inline-block !important;
      margin: 10px 0 !important;
      vertical-align: middle !important;
    }
    
    /* Background images */
    .bi {
      position: static !important;
      display: inline-block !important;
      max-width: 100% !important;
      height: auto !important;
      margin: 10px 0 !important;
      vertical-align: middle !important;
    }
    
    /* Page containers */
    [id^="pf"] {
      position: static !important;
      margin: 0 0 20px 0 !important;
      padding: 20px !important;
      width: auto !important;
      height: auto !important;
      background: white !important;
      border-radius: 8px !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }
    
    /* Page content */
    [class^="pc"] {
      position: static !important;
      width: auto !important;
      height: auto !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* Hide sidebar */
    #sidebar {
      display: none !important;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      img, .bi {
        max-width: 100% !important;
        margin: 8px 0 !important;
      }
      
      [id^="pf"] {
        margin: 10px 0 !important;
        padding: 15px !important;
      }
    }
    </style>
    `;
    
    // Inject CSS into the HTML head
    if (htmlContent.includes('</head>')) {
      htmlContent = htmlContent.replace('</head>', `${customCss}\n</head>`);
    } else if (htmlContent.includes('<html>')) {
      htmlContent = htmlContent.replace('<html>', '<html>\n<head>' + customCss + '\n</head>');
    } else {
      // If no head tag, prepend the CSS
      htmlContent = customCss + '\n' + htmlContent;
    }
    
    console.log('HTML content generated with injected custom CSS');

    // Upload images to Supabase Storage and update HTML references
    const imageFiles = files.filter(file => file.match(/\.(png|jpg|jpeg|gif|svg)$/i));
    console.log('Found image files:', imageFiles);
    
    // Prepare image data for client-side upload
    const imageData: { [key: string]: string } = {};
    
    if (imageFiles.length > 0) {
      for (const imageFile of imageFiles) {
        const imagePath = join(outputDir, imageFile);
        console.log(`Processing image: ${imageFile} at path: ${imagePath}`);
        
        if (!existsSync(imagePath)) {
          console.error(`Image file not found: ${imagePath}`);
          continue;
        }
        
        const imageBuffer = readFileSync(imagePath);
        console.log(`Image file size: ${imageBuffer.length} bytes`);
        
        // Convert buffer to base64 for client-side processing
        imageData[imageFile] = imageBuffer.toString('base64');
      }
    } else {
      console.log('No image files found to upload');
    }

    // Clean up temporary files
    try {
      for (const file of files) {
        const filePath = join(outputDir, file);
        unlinkSync(filePath);
      }
      // Remove directories
      unlinkSync(pdfPath);
      // Note: We don't remove the temp directory as it might be in use
    } catch (cleanupError) {
      console.error('Cleanup error:', cleanupError);
    }

    console.log('Server action - Conversion completed successfully');
    console.log('HTML content length:', htmlContent.length);
    console.log('Image files to upload:', Object.keys(imageData));
    
    return { 
      success: true, 
      htmlContent,
      imageData: Object.keys(imageData).length > 0 ? imageData : null
    };

  } catch (error) {
    console.error('PDF conversion error:', error);
    throw new Error(`PDF conversion failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
} 